/**
 * Base generator class that all generators extend
 */

import type { IRSchema } from '../ir/types.js';
import { type CodePrinter, createPrinter } from '../codegen/printer.js';
import { formatCode, type FormatConfig } from '../codegen/formatter.js';
import { writeFile, ensureDir } from '../utils/fs.js';
import { logger } from '../utils/logger.js';
import { dirname, join } from 'node:path';

/** Generator output file */
export interface GeneratedFile {
  path: string;
  content: string;
}

/** Output split mode */
export type SplitOutputMode = 'single' | 'by-type' | 'by-endpoint';

/** Base generator options */
export interface GeneratorOptions {
  /** Output directory */
  outputDir: string;
  /** Format configuration */
  format?: FormatConfig;
  /** Whether to use barrel exports */
  barrelExports?: boolean;
  /** How to split output files */
  splitOutput?: SplitOutputMode;
}

/**
 * Base generator class
 */
export abstract class BaseGenerator {
  protected printer: CodePrinter;
  protected files: GeneratedFile[] = [];

  constructor(
    protected schema: IRSchema,
    protected options: GeneratorOptions
  ) {
    this.printer = createPrinter();
  }

  /**
   * Get the name of this generator
   */
  abstract get name(): string;

  /**
   * Get the output filename for this generator
   */
  abstract get filename(): string;

  /**
   * Generate code from the IR schema
   */
  abstract generate(): void;

  /**
   * Run the generator and return generated files
   */
  async run(): Promise<GeneratedFile[]> {
    logger.step(`Generating ${this.name}...`);

    // Generate code
    this.generate();

    // Format code if enabled
    const content = this.printer.toString();
    const formattedContent = await formatCode(content, this.options.format);

    // Create the generated file
    const file: GeneratedFile = {
      path: join(this.options.outputDir, this.filename),
      content: formattedContent,
    };

    this.files.push(file);

    logger.success(`Generated ${this.filename}`);

    return this.files;
  }

  /**
   * Write generated files to disk
   */
  async write(): Promise<void> {
    ensureDir(this.options.outputDir);

    for (const file of this.files) {
      ensureDir(dirname(file.path));
      writeFile(file.path, file.content);
      logger.debug(`Wrote ${file.path}`);
    }
  }

  /**
   * Reset the generator state
   */
  protected reset(): void {
    this.printer.clear();
    this.files = [];
  }

  /**
   * Add a header comment to the generated file
   */
  protected addHeader(): void {
    this.printer.comment('This file was auto-generated by Bridge');
    this.printer.comment('Do not edit this file directly');
    this.printer.blank();
  }

  /**
   * Add standard type imports
   */
  protected addTypeImports(types: string[], from: string): void {
    if (types.length > 0) {
      this.printer.importType(types, from);
    }
  }

  /**
   * Create a new printer and return it (for multi-file generation)
   */
  protected createFilePrinter(): CodePrinter {
    return createPrinter();
  }

  /**
   * Add a file to the output (for multi-file generation)
   */
  protected async addFile(relativePath: string, content: string): Promise<void> {
    const formattedContent = await formatCode(content, this.options.format);
    this.files.push({
      path: join(this.options.outputDir, relativePath),
      content: formattedContent,
    });
  }

  /**
   * Add a file from a printer (for multi-file generation)
   */
  protected async addFileFromPrinter(relativePath: string, printer: CodePrinter): Promise<void> {
    await this.addFile(relativePath, printer.toString());
  }

  /**
   * Generate a barrel export file (index.ts)
   */
  protected generateBarrelExport(exports: string[], _directory: string = ''): string {
    const printer = createPrinter();
    printer.comment('This file was auto-generated by Bridge');
    printer.comment('Do not edit this file directly');
    printer.blank();

    for (const name of exports) {
      printer.line(`export * from './${name}.js';`);
    }

    return printer.toString();
  }

  /**
   * Check if using multi-file output mode
   */
  protected get isMultiFile(): boolean {
    return this.options.splitOutput !== undefined && this.options.splitOutput !== 'single';
  }
}

/**
 * Generator registry for managing multiple generators
 */
export class GeneratorRegistry {
  private generators: Map<string, typeof BaseGenerator> = new Map();

  /**
   * Register a generator
   */
  register(name: string, generator: typeof BaseGenerator): void {
    this.generators.set(name, generator);
  }

  /**
   * Get a generator by name
   */
  get(name: string): typeof BaseGenerator | undefined {
    return this.generators.get(name);
  }

  /**
   * Get all registered generator names
   */
  names(): string[] {
    return Array.from(this.generators.keys());
  }
}

/** Default generator registry */
export const generatorRegistry = new GeneratorRegistry();

// This file was auto-generated by Bridge
// Do not edit this file directly

import type {
  ListPetsParams,
  ListPetsResponse,
  CreatePetParams,
  CreatePetResponse,
  GetPetParams,
  GetPetResponse,
  UpdatePetParams,
  UpdatePetResponse,
  DeletePetParams,
  DeletePetResponse,
  UploadPetPhotoParams,
  UploadPetPhotoResponse,
} from './types.js';

export interface ClientConfig {
  baseUrl: string;
  headers?: Record<string, string>;
  credentials?: RequestCredentials;
  fetch?: typeof fetch;
  onRequest?: (request: RequestInit) => RequestInit | Promise<RequestInit>;
  onResponse?: (response: Response) => Response | Promise<Response>;
  onError?: (error: Error) => void;
}

export interface RequestOptions {
  params?: Record<string, string | number | boolean | undefined>;
  query?: Record<string, string | number | boolean | undefined>;
  headers?: Record<string, string>;
  body?: unknown;
  signal?: AbortSignal;
}

/**
 * API error with status code and response data
 */
export class ApiError extends Error {
  constructor(
    public readonly status: number,
    public readonly statusText: string,
    public readonly data: unknown,
    message?: string
  ) {
    super(message ?? `API Error: ${status} ${statusText}`);
    this.name = 'ApiError';
  }
}

const defaultConfig: ClientConfig = {
  baseUrl: 'https://api.petstore.example.com/v1',
};

/**
 * HTTP client for making API requests
 */
export class HttpClient {
  private config: ClientConfig;

  constructor(config: Partial<ClientConfig> = {}) {
    this.config = { ...defaultConfig, ...config };
  }

  async request<T>(method: string, path: string, options: RequestOptions = {}): Promise<T> {
    let url = this.buildUrl(path, options.params);

    if (options.query) {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(options.query)) {
        if (value !== undefined) {
          searchParams.append(key, String(value));
        }
      }
      const queryString = searchParams.toString();
      if (queryString) {
        url += `?${queryString}`;
      }
    }

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...this.config.headers,
      ...options.headers,
    };

    let init: RequestInit = {
      method,
      headers,
      credentials: this.config.credentials,
      signal: options.signal,
    };

    if (options.body !== undefined) {
      init.body = JSON.stringify(options.body);
    }

    if (this.config.onRequest) {
      init = await this.config.onRequest(init);
    }

    const fetchFn = this.config.fetch ?? fetch;
    let response = await fetchFn(url, init);

    if (this.config.onResponse) {
      response = await this.config.onResponse(response);
    }

    if (!response.ok) {
      let data: unknown;
      try {
        data = await response.json();
      } catch {
        data = await response.text();
      }
      const error = new ApiError(response.status, response.statusText, data);
      this.config.onError?.(error);
      throw error;
    }

    const contentType = response.headers.get('content-type');
    if (contentType?.includes('application/json')) {
      return response.json();
    }

    return undefined as T;
  }

  private buildUrl(
    path: string,
    params?: Record<string, string | number | boolean | undefined>
  ): string {
    let url = `${this.config.baseUrl}${path}`;

    if (params) {
      for (const [key, value] of Object.entries(params)) {
        if (value !== undefined) {
          url = url.replace(`{${key}}`, encodeURIComponent(String(value)));
        }
      }
    }

    return url;
  }

  get<T>(path: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('GET', path, options);
  }

  post<T>(path: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('POST', path, options);
  }

  put<T>(path: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('PUT', path, options);
  }

  patch<T>(path: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('PATCH', path, options);
  }

  delete<T>(path: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('DELETE', path, options);
  }
}
/**
 * API client for making typed requests
 */
export class ApiClient {
  private http: HttpClient;

  constructor(config?: Partial<ClientConfig>) {
    this.http = new HttpClient(config);
  }

  /**
   * List all pets
   *
   * Returns all pets from the system
   */
  async listPets(params?: ListPetsParams, signal?: AbortSignal): Promise<ListPetsResponse> {
    const options: RequestOptions = {
      query: params?.query,
      signal,
    };

    return this.http.request<ListPetsResponse>('GET', '/pets', options);
  }

  /**
   * Create a pet
   *
   * Creates a new pet in the store
   */
  async createPet(params: CreatePetParams, signal?: AbortSignal): Promise<CreatePetResponse> {
    const options: RequestOptions = {
      body: params?.body,
      signal,
    };

    return this.http.request<CreatePetResponse>('POST', '/pets', options);
  }

  /**
   * Get a pet by ID
   *
   * Returns a single pet by its ID
   */
  async getPet(params: GetPetParams, signal?: AbortSignal): Promise<GetPetResponse> {
    const options: RequestOptions = {
      signal,
    };

    return this.http.request<GetPetResponse>('GET', `/pets/${params.path.petId}`, options);
  }

  /**
   * Update a pet
   *
   * Updates an existing pet
   */
  async updatePet(params: UpdatePetParams, signal?: AbortSignal): Promise<UpdatePetResponse> {
    const options: RequestOptions = {
      body: params?.body,
      signal,
    };

    return this.http.request<UpdatePetResponse>('PUT', `/pets/${params.path.petId}`, options);
  }

  /**
   * Delete a pet
   *
   * Deletes a pet from the store
   */
  async deletePet(params: DeletePetParams, signal?: AbortSignal): Promise<DeletePetResponse> {
    const options: RequestOptions = {
      signal,
    };

    return this.http.request<DeletePetResponse>('DELETE', `/pets/${params.path.petId}`, options);
  }

  /**
   * Upload a pet photo
   */
  async uploadPetPhoto(
    params: UploadPetPhotoParams,
    signal?: AbortSignal
  ): Promise<UploadPetPhotoResponse> {
    const options: RequestOptions = {
      body: params?.body,
      signal,
    };

    return this.http.request<UploadPetPhotoResponse>(
      'POST',
      `/pets/${params.path.petId}/photos`,
      options
    );
  }
}

/**
 * Default API client instance
 */
export const apiClient = new ApiClient();

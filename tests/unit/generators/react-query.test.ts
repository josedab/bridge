import { describe, it, expect, beforeAll } from 'vitest';
import { resolve } from 'node:path';
import { parseOpenAPI } from '../../../src/parsers/openapi/index.js';
import { ReactQueryGenerator } from '../../../src/generators/react-query/index.js';
import type { IRSchema } from '../../../src/ir/types.js';

describe('React Query Generator', () => {
  let schema: IRSchema;
  let generatedCode: string;

  beforeAll(async () => {
    const fixturesPath = resolve(__dirname, '../../fixtures/openapi/petstore.yaml');
    schema = await parseOpenAPI(fixturesPath);

    const generator = new ReactQueryGenerator(schema, {
      outputDir: '/tmp/test-output',
    });
    generator.generate();
    generatedCode = generator['printer'].toString();
  });

  describe('imports generation', () => {
    it('should import from @tanstack/react-query', () => {
      expect(generatedCode).toContain("from '@tanstack/react-query'");
    });

    it('should import useQuery', () => {
      expect(generatedCode).toContain('useQuery');
    });

    it('should import useMutation', () => {
      expect(generatedCode).toContain('useMutation');
    });

    it('should import UseQueryOptions', () => {
      expect(generatedCode).toContain('UseQueryOptions');
    });

    it('should import apiClient', () => {
      expect(generatedCode).toContain("import { apiClient } from './client.js'");
    });

    it('should import types', () => {
      expect(generatedCode).toContain("from './types.js'");
    });
  });

  describe('query keys generation', () => {
    it('should generate query keys object', () => {
      expect(generatedCode).toMatch(/export\s+const\s+\w+Keys/);
    });
  });

  describe('query hooks generation', () => {
    it('should generate Query Hooks section', () => {
      expect(generatedCode).toContain('=== Query Hooks ===');
    });

    it('should generate useQuery hook for GET endpoints', () => {
      expect(generatedCode).toMatch(/export\s+function\s+use\w+/);
    });
  });

  describe('mutation hooks generation', () => {
    it('should generate Mutation Hooks section', () => {
      expect(generatedCode).toContain('=== Mutation Hooks ===');
    });
  });

  describe('code formatting', () => {
    it('should include auto-generated comment', () => {
      expect(generatedCode).toContain('This file was auto-generated by Bridge');
    });
  });
});

describe('React Query Generator - Suspense', () => {
  let schema: IRSchema;
  let generatedCode: string;

  beforeAll(async () => {
    const fixturesPath = resolve(__dirname, '../../fixtures/openapi/petstore.yaml');
    schema = await parseOpenAPI(fixturesPath);

    const generator = new ReactQueryGenerator(schema, {
      outputDir: '/tmp/test-output',
      suspense: true,
    });
    generator.generate();
    generatedCode = generator['printer'].toString();
  });

  it('should import useSuspenseQuery', () => {
    expect(generatedCode).toContain('useSuspenseQuery');
  });

  it('should import UseSuspenseQueryOptions', () => {
    expect(generatedCode).toContain('UseSuspenseQueryOptions');
  });
});

describe('React Query Generator - Infinite', () => {
  let schema: IRSchema;
  let generatedCode: string;

  beforeAll(async () => {
    const fixturesPath = resolve(__dirname, '../../fixtures/openapi/petstore.yaml');
    schema = await parseOpenAPI(fixturesPath);

    const generator = new ReactQueryGenerator(schema, {
      outputDir: '/tmp/test-output',
      infinite: true,
    });
    generator.generate();
    generatedCode = generator['printer'].toString();
  });

  it('should import useInfiniteQuery', () => {
    expect(generatedCode).toContain('useInfiniteQuery');
  });

  it('should import UseInfiniteQueryOptions', () => {
    expect(generatedCode).toContain('UseInfiniteQueryOptions');
  });
});

describe('React Query Generator - Edge Cases', () => {
  it('should handle empty schema', () => {
    const emptySchema: IRSchema = {
      metadata: {
        title: 'Empty API',
        version: '1.0.0',
        source: 'openapi',
      },
      types: new Map(),
      endpoints: [],
      operations: [],
    };

    const generator = new ReactQueryGenerator(emptySchema, {
      outputDir: '/tmp/test-output',
    });
    generator.generate();
    const code = generator['printer'].toString();

    expect(code).toContain('This file was auto-generated by Bridge');
    expect(code).toContain("from '@tanstack/react-query'");
  });

  it('should handle schema with only mutation endpoints', () => {
    const mutationSchema: IRSchema = {
      metadata: {
        title: 'Mutation API',
        version: '1.0.0',
        source: 'openapi',
      },
      types: new Map(),
      endpoints: [
        {
          operationId: 'createItem',
          path: '/items',
          method: 'post',
          parameters: [],
          responses: [{ statusCode: '201', description: 'Created', content: [] }],
        },
      ],
      operations: [],
    };

    const generator = new ReactQueryGenerator(mutationSchema, {
      outputDir: '/tmp/test-output',
    });
    generator.generate();
    const code = generator['printer'].toString();

    expect(code).toContain('=== Mutation Hooks ===');
  });
});

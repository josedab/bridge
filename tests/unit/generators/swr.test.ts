import { describe, it, expect, beforeAll } from 'vitest';
import { resolve } from 'node:path';
import { parseOpenAPI } from '../../../src/parsers/openapi/index.js';
import { SwrGenerator } from '../../../src/generators/swr/index.js';
import type { IRSchema } from '../../../src/ir/types.js';

describe('SWR Generator', () => {
  let schema: IRSchema;
  let generatedCode: string;

  beforeAll(async () => {
    const fixturesPath = resolve(__dirname, '../../fixtures/openapi/petstore.yaml');
    schema = await parseOpenAPI(fixturesPath);

    const generator = new SwrGenerator(schema, {
      outputDir: '/tmp/test-output',
    });
    generator.generate();
    generatedCode = generator['printer'].toString();
  });

  describe('imports generation', () => {
    it('should import from swr', () => {
      expect(generatedCode).toContain("from 'swr'");
    });

    it('should import useSWR', () => {
      expect(generatedCode).toContain('useSWR');
    });

    it('should import SWRConfiguration', () => {
      expect(generatedCode).toContain('SWRConfiguration');
    });

    it('should import from swr/mutation', () => {
      expect(generatedCode).toContain("from 'swr/mutation'");
    });

    it('should import useSWRMutation', () => {
      expect(generatedCode).toContain('useSWRMutation');
    });

    it('should import apiClient', () => {
      expect(generatedCode).toContain("import { apiClient } from './client.js'");
    });

    it('should import types', () => {
      expect(generatedCode).toContain("from './types.js'");
    });
  });

  describe('SWR keys generation', () => {
    it('should generate SWR keys', () => {
      expect(generatedCode).toMatch(/export\s+const\s+\w+Keys/);
    });
  });

  describe('query hooks generation', () => {
    it('should generate SWR Query Hooks section', () => {
      expect(generatedCode).toContain('=== SWR Query Hooks ===');
    });

    it('should generate useSWR hook for GET endpoints', () => {
      expect(generatedCode).toMatch(/export\s+function\s+use\w+/);
    });
  });

  describe('mutation hooks generation', () => {
    it('should generate SWR Mutation Hooks section', () => {
      expect(generatedCode).toContain('=== SWR Mutation Hooks ===');
    });
  });

  describe('code formatting', () => {
    it('should include auto-generated comment', () => {
      expect(generatedCode).toContain('This file was auto-generated by Bridge');
    });
  });
});

describe('SWR Generator - Immutable', () => {
  let schema: IRSchema;
  let generatedCode: string;

  beforeAll(async () => {
    const fixturesPath = resolve(__dirname, '../../fixtures/openapi/petstore.yaml');
    schema = await parseOpenAPI(fixturesPath);

    const generator = new SwrGenerator(schema, {
      outputDir: '/tmp/test-output',
      immutable: true,
    });
    generator.generate();
    generatedCode = generator['printer'].toString();
  });

  it('should import useSWRImmutable', () => {
    expect(generatedCode).toContain('useSWRImmutable');
  });
});

describe('SWR Generator - Infinite', () => {
  let schema: IRSchema;
  let generatedCode: string;

  beforeAll(async () => {
    const fixturesPath = resolve(__dirname, '../../fixtures/openapi/petstore.yaml');
    schema = await parseOpenAPI(fixturesPath);

    const generator = new SwrGenerator(schema, {
      outputDir: '/tmp/test-output',
      infinite: true,
    });
    generator.generate();
    generatedCode = generator['printer'].toString();
  });

  it('should import useSWRInfinite', () => {
    expect(generatedCode).toContain('useSWRInfinite');
  });

  it('should import SWRInfiniteConfiguration', () => {
    expect(generatedCode).toContain('SWRInfiniteConfiguration');
  });
});

describe('SWR Generator - Edge Cases', () => {
  it('should handle empty schema', () => {
    const emptySchema: IRSchema = {
      metadata: {
        title: 'Empty API',
        version: '1.0.0',
        source: 'openapi',
      },
      types: new Map(),
      endpoints: [],
      operations: [],
    };

    const generator = new SwrGenerator(emptySchema, {
      outputDir: '/tmp/test-output',
    });
    generator.generate();
    const code = generator['printer'].toString();

    expect(code).toContain('This file was auto-generated by Bridge');
    expect(code).toContain("from 'swr'");
  });

  it('should handle schema with only mutation endpoints', () => {
    const mutationSchema: IRSchema = {
      metadata: {
        title: 'Mutation API',
        version: '1.0.0',
        source: 'openapi',
      },
      types: new Map(),
      endpoints: [
        {
          operationId: 'deleteItem',
          path: '/items/{id}',
          method: 'delete',
          parameters: [
            {
              name: 'id',
              in: 'path',
              required: true,
              type: { kind: 'ref', name: 'string' },
            },
          ],
          responses: [{ statusCode: '204', description: 'Deleted', content: [] }],
        },
      ],
      operations: [],
    };

    const generator = new SwrGenerator(mutationSchema, {
      outputDir: '/tmp/test-output',
    });
    generator.generate();
    const code = generator['printer'].toString();

    expect(code).toContain('=== SWR Mutation Hooks ===');
  });
});

import { describe, it, expect, beforeAll } from 'vitest';
import { resolve } from 'node:path';
import { parseOpenAPI } from '../../../src/parsers/openapi/index.js';
import { TypeScriptGenerator } from '../../../src/generators/typescript/index.js';
import type { IRSchema } from '../../../src/ir/types.js';

describe('TypeScript Generator', () => {
  let schema: IRSchema;
  let generatedCode: string;

  beforeAll(async () => {
    const fixturesPath = resolve(__dirname, '../../fixtures/openapi/petstore.yaml');
    schema = await parseOpenAPI(fixturesPath);

    const generator = new TypeScriptGenerator(schema, {
      outputDir: '/tmp/test-output',
    });
    generator.generate();
    generatedCode = generator['printer'].toString();
  });

  describe('type generation', () => {
    it('should generate Pet interface', () => {
      expect(generatedCode).toContain('export interface Pet');
    });

    it('should generate PetStatus enum', () => {
      expect(generatedCode).toContain('export enum PetStatus');
      expect(generatedCode).toContain("Available = 'available'");
    });

    it('should generate Owner interface', () => {
      expect(generatedCode).toContain('export interface Owner');
    });

    it('should generate Error interface', () => {
      expect(generatedCode).toContain('export interface Error');
    });

    it('should mark required properties without ?', () => {
      // Pet.id should be required
      expect(generatedCode).toMatch(/id:\s*string/);
    });

    it('should mark optional properties with ?', () => {
      // Pet.breed should be optional
      expect(generatedCode).toMatch(/breed\?:\s*string/);
    });
  });

  describe('endpoint types generation', () => {
    it('should generate params types for endpoints', () => {
      expect(generatedCode).toContain('export interface ListPetsParams');
      expect(generatedCode).toContain('export interface GetPetParams');
    });

    it('should generate response types for endpoints', () => {
      expect(generatedCode).toContain('export type ListPetsResponse');
      expect(generatedCode).toContain('export type GetPetResponse');
    });

    it('should generate OperationId union type', () => {
      expect(generatedCode).toContain('export type OperationId');
      expect(generatedCode).toContain("'listPets'");
      expect(generatedCode).toContain("'getPet'");
    });
  });

  describe('code formatting', () => {
    it('should include auto-generated comment', () => {
      expect(generatedCode).toContain('This file was auto-generated by Bridge');
    });

    it('should generate valid TypeScript syntax', () => {
      // Basic syntax checks
      expect(generatedCode).not.toContain('undefined:');
      expect(generatedCode).not.toContain('null:');
    });
  });
});

describe('TypeScript Generator - Edge Cases', () => {
  it('should handle empty schema', async () => {
    const emptySchema: IRSchema = {
      metadata: {
        title: 'Empty API',
        version: '1.0.0',
        source: 'openapi',
      },
      types: new Map(),
      endpoints: [],
      operations: [],
    };

    const generator = new TypeScriptGenerator(emptySchema, {
      outputDir: '/tmp/test-output',
    });
    generator.generate();
    const code = generator['printer'].toString();

    expect(code).toContain('This file was auto-generated by Bridge');
  });
});
